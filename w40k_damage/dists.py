# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_dists.ipynb.

# %% auto 0
__all__ = ['convolve', 'mult_ddist_vals', 'mult_ddist_probs', 'threshold_ddist', 'add_ddist', 'flatdist', 'fnp_transform',
           'dd_prune', 'dd_rep', 'dd_mean', 'dd_quantile', 'dd_above', 'dd_max', 'dd_psum', 'dd_cap', 'find_kw',
           'agg_mod_kw', 'single_dam_dist', 'atk_success_prob', 'atk_success_dist', 'successful_atk_dist', 'dam_dist',
           'fulldist_convolve']

# %% ../nbs/01_dists.ipynb 1
import numpy, re
from collections import defaultdict
from math import ceil, floor, comb, isnan

# %% ../nbs/01_dists.ipynb 3
# Convolution of d1 and d2
# NB! For damage, use dam_convolve
def convolve(d1,d2):
    res = defaultdict(lambda: 0)
    for k1,v1 in d1.items():
        for k2,v2 in d2.items():
            res[k1+k2] += v1*v2    
    return res


# %% ../nbs/01_dists.ipynb 4
# Other helper functions for distributions
# TODO: this is better encapsulated into a class

def mult_ddist_vals(d, val):
    res = defaultdict(lambda: 0)
    for k1,v1 in d.items():
        res[int(ceil(k1*val))] += v1 
    return res

def mult_ddist_probs(d,p):
    return { k:v*p for k,v in d.items() }

def threshold_ddist(dd,val,lt=True):
    for k in list(dd.keys()): 
        if (lt and k<val) or (not lt and k>val): 
            dd[val]+=dd[k]
            del dd[k]

def add_ddist(d1,d2):
    res = defaultdict(lambda: 0)
    for k1,v1 in d1.items():
        res[k1] += v1  
    for k2,v2 in d2.items():
        res[k2] += v2 
    return res
    
def flatdist(n):
    return { (i+1):1/n for i in range(n) }

# q is the probability of saving the damage
def fnp_transform(d, q):
    p = 1.0-q
    res = defaultdict(lambda: 0)
    for k,v in d.items():
        for i in range(k+1): # Binomial distribution
            res[i] += v*comb(k,i)*(p**i)*(q**(k-i))
    return res

# Prune all values with prob below ratio * <max prob>
def dd_prune(d, ratio):
    t = ratio*max(d.values())
    return { k:v for k,v in d.items() if v>t }


# Repeat dist d n times
def dd_rep(d, n):
    if n == 0 : return { 0: 1 }
    res_d = d
    for _ in range(1,n):
        res_d = dd_prune(convolve(res_d,d),1e-3)
    return res_d

def dd_mean(dd):
    val = 0.0
    for k, v in dd.items():
        val += k*v
    return val


def dd_quantile(dd,q):
    cum = 0.0
    for k,v in sorted(dd.items()):
        cum += v
        if cum>=q: return k
    return None

# above-or-equal
def dd_above(d, thresh):
    p = 0.0
    for k,v in d.items():
        if k<thresh: p+=v
    # This approach is better if we prune the dist
    return 1.0-p


def dd_max(dd):
    return max(dd.keys())

def dd_psum(dd):
    return sum(dd.values())

# Cap the value at maxv
def dd_cap(d, maxv):
    res = { v: p for v, p in d.items() if v<maxv }
    res[maxv] = dd_above(d,maxv)
    return res


# %% ../nbs/01_dists.ipynb 5
def dd_from_str(dstr):
    dd = { 0: 1.0 }
    for t in dstr.lower().split('+'):
        if 'd' in t:
            d = t.split('d')
            if d[0]=='': d = [1,int(d[1])]
            else: d = list(map(int,d))
            for _ in range(d[0]):
                nd = flatdist(d[1])
                dd = convolve(dd,nd)
        else:
            d = int(t)
            dd = convolve(dd,{d:1.0})
    return dd

# %% ../nbs/01_dists.ipynb 6
# Return suffix of the kw if found, and None otherwise
def find_kw(kw,kws):
    sus = None
    for k in kws:
        if k.startswith(kw):
            sus = k[len(kw):].strip()
    return sus

# Aggregate over different effects  of the same type
def agg_mod_kw(kw,kws):
    eff = 0
    for k in kws:
        if k.startswith(kw):
            eff += int(k[len(kw):].strip())
    return eff

# %% ../nbs/01_dists.ipynb 7
def single_dam_dist(wep, target, situation={}):

    # Create dmgstr distribution
    dd = dd_from_str(wep['damage'])

    # Apply div/mult modifiers - Ç¸B order matters  
    if 'halve damage' in target['abilities']: dd = mult_ddist_vals(dd,1.0/2)
    if 'double damage' in wep['kws']: dd = mult_ddist_probs(dd,2)

    # Threshold to 1
    dr = find_kw('damage reduction', target['abilities'])
    if dr: dd = convolve(dd,{-int(dr):1.0})
    threshold_ddist(dd,1,True)

    # Melta - after div and mult
    melta = find_kw('melta',wep['kws'])
    if melta and situation.get('range',False): 
        #print("MELTA",melta)
        dd = convolve(dd,dd_from_str(melta))

    # Apply FNP
    fnp = find_kw('feel no pain',target['abilities'])
    if fnp: 
        #print("FNP",fnp)
        fnp = int(fnp.strip('+'))
        dd = fnp_transform(dd,(7-fnp)/6)

    # Threshold to n_wounds
    threshold_ddist(dd,target['wounds'],False)

    #print(dd_mean(dd))

    return dd
    

# %% ../nbs/01_dists.ipynb 8
def get_hit_probs(wep,target,situation={}):

    # Prob to hit
    if 'torrent' in wep['kws']:
        p_hcrit, p_hit = 0, 1
    else:
        hc = find_kw('hit crit',wep['kws'])
        hit_crit = int(hc.strip('+')) if hc else 6
        
        p_hcrit = (7-hit_crit)/6.0

        hit_t = wep['bsws']

        # Stealth
        ih = agg_mod_kw('mod hits',wep['kws'])
        if wep['type']=='ranged' and 'stealth' in target['abilities']: ih +=1
        
        hit_t -= max(-1,min(1,ih))

        p_hit = max((6*p_hcrit),min(5, # hit_crit always hits, 1 always misses
                    (7-hit_t)))/6.0
        
        if situation.get('overwatch') and wep['type']=='ranged': # Only on an unmodified roll of 6
            p_hit = p_hcrit = 1/6.0
        elif situation.get('indirect') and 'indirect fire' in wep['kws']: # Only on an unmodified roll of 4+
            p_hit = min(p_hit,0.5)
            p_hcrit = min(p_hcrit,0.5)
        
        if 'reroll hits' in wep['kws']:
            p_hit += (1-p_hit)*p_hit
            p_hcrit += (1-p_hit)*p_hcrit
        elif 'reroll 1s to hit' in wep['kws']:
            p_hit += (1/6.0)*p_hit
            p_hcrit += (1/6.0)*p_hcrit
            

    return p_hit,p_hcrit

# %% ../nbs/01_dists.ipynb 9
def atk_success_prob(wep, target, situation={}, crit_hit=None, verbose=False):

    # TODO:
    # Rerolls (1 and all)
    # Fish-for-sixes if better.

    # Probs to hit
    
        
    # Check if fn parameter already tells us if it was a crit or not
    # This behavior is needed for Sustained hits as they also affect hit counts
    if crit_hit: p_hcrit,p_hit = 1,1
    elif crit_hit==False: p_hcrit,p_hit = 0, 1
    else: p_hit, p_hcrit = get_hit_probs(wep, target, situation)

    if verbose: print("Hit",p_hit,p_hcrit)

    # Prob to wound

    # Get crit wound threshold (ANTI keywords)
    wc = find_kw('wound crit',wep['kws'])
    wound_crit = int(wc.strip('+')) if wc else 6
    
    for k in wep['kws']:
        if k.startswith('anti-'):
            kw,val = k[5:].split(' ')
            if kw in target['kws']: 
                #print("Anti",kw,val)
                wound_crit = min(wound_crit,int(val.strip('+')))    

    p_wcrit = (7-wound_crit)/6.0

    st, tgh = wep['strength'], target['toughness']
    st += int(find_kw('mod strength',wep['kws']) or 0)
    tgh += int(find_kw('mod toughness',target['abilities']) or 0)

    if st>tgh:
        if st>=2*tgh:
            p_wound = 5
        else: p_wound = 4
    elif st<tgh:
        if 2*st<=tgh:
            p_wound = 1
        else: p_wound = 2
    else: p_wound = 3

    iw = agg_mod_kw('mod wounds',wep['kws'])
    p_wound += max(-1,min(1,iw))
    p_wound /= 6

    p_wound = min(5/6,max(p_wcrit,p_wound))

    if 'twin-linked' in wep['kws'] or 'reroll wounds' in wep['kws']:
        #print("Twinlinked")
        p_wound += (1-p_wound)*p_wound
        p_wcrit += (1-p_wound)*p_wcrit
    elif 'reroll 1s to wound'  in wep['kws']:
        p_wound += (1/6.0)*p_wound
        p_wcrit += (1/6.0)*p_wcrit

    if verbose: print("Wound",p_wound,p_wcrit)

    # Prob to not save
    ap = wep['AP'] # NB! this is negative as in datasheets
    ap += max(-1,min(1,agg_mod_kw('mod ap',wep['kws'])))
    
    # Cover effect - positive to neutralize the neg
    c_eff = 0 if (not situation.get('cover') or wep['type']!='ranged' or 
                'ignores cover' in wep['kws'] or 
                (ap==0 and target['save']<=3)) else 1
    
    save = min(target['invuln'] or 10,target['save']-ap-c_eff)
    p_nsave = 1.0 - max(0,min(6,7-save))/6.0

    if 'devastating wounds' in wep['kws']: # Devastating wounds
        #print("devwounds")
        p_nsave = ((p_wound-p_wcrit)*p_nsave + p_wcrit)/p_wound

    if verbose: print("Save",p_nsave)

    # Total probability
    if 'lethal hits' in wep['kws']:
        #print("lethal hits")
        p_dam = p_hcrit*p_nsave + (p_hit-p_hcrit)*p_wound*p_nsave
    else:
        p_dam = p_hit*p_wound*p_nsave

    if verbose: print("Total prob", p_dam)

    return p_dam

# %% ../nbs/01_dists.ipynb 10
# Create res as weighted sum of repeated convolutions with weights given by b_dd and repeated self-convolutons of r_dd
def dd_over_dd(b_dd,r_dd,base=0):
    cur_d,res_d = {base: 1.0}, {0: b_dd.get(0,0.0)}
    for i in range(1,dd_max(b_dd)+1):
        cur_d = convolve(cur_d,r_dd)
        if i in b_dd:
            res_d = add_ddist(res_d,mult_ddist_probs(cur_d,b_dd[i]))
    return res_d

# %% ../nbs/01_dists.ipynb 11
# Wrapper around atk_success_prob that handles sustained hits
def atk_success_dist(wep,target,situation={}):

    # Find number of sustained hits
    sus = find_kw('sustained hits',wep['kws'])

    # Handle the easy case (no sustained hits)
    if not sus:
        p = atk_success_prob(wep,target,situation)
        return { 1: p, 0: (1-p) }
    
    # Sustained hits:
    #print("Sustained",sus)
    sus_d = dd_from_str(sus)
    
    p_hit, p_hcrit = get_hit_probs(wep,target,situation)
    pc = atk_success_prob(wep,target,situation,True)
    pn = atk_success_prob(wep,target,situation,False)

    #p = pn*(1-p_hcrit)
    normal = { 1: pn, 0: (1-pn) }
    crit = { 1: pc, 0: (1-pc) }
    crit = convolve(crit,dd_over_dd(sus_d,normal))
    
    normal = mult_ddist_probs(normal,p_hit-p_hcrit)
    crit = mult_ddist_probs(crit,p_hcrit)

    total =  add_ddist(normal, crit)
    total[0] += 1.0-p_hit

    return total


# %% ../nbs/01_dists.ipynb 12
def successful_atk_dist(wep,target, situation={}):
    s_range = situation.get('range',False)
    if s_range not in [True,False]: s_range = (s_range<=wep['range']/2)

    # Base attack number dist
    an_d = dd_from_str(wep['attacks'])

    # Rapid fire
    rfire = find_kw('rapid fire',wep['kws'])
    if rfire and s_range: 
        #print("Rapidfire",rfire)
        an_d = convolve(an_d,dd_from_str(rfire))

    # Other added attacks, incl Blast
    added_attacks = 0
    if 'blast' in wep['kws'] and target.get('models',0)>=5:
        #print("Blast")
        added_attacks += target['models']//5
    if added_attacks!=0:
        an_d = convolve(an_d,{added_attacks:1})

    # Attack successes dist for an individual attack
    as_d = atk_success_dist(wep,target,situation)

    # Create res as weighted sum of repeated convolutions
    res_d = dd_over_dd(an_d,as_d)

    return res_d

# %% ../nbs/01_dists.ipynb 13
# Damage requires its own convolutions that account for n_wounds and first_n
# This is faster than fulldist_convolve, under the specific circumstances it is used
# It only works under those very specific circumstances, unfortunately

# Convolve the damage dist of a single shot ds into aggregate da
# This assumes ds is capped at n_wounds max.
# Note that the order of operations on this really matters because
# capping n_wounds makes the convolution non-associative, and first_n non-commutative
def dam_convolve(da,ds,n_wounds,first_n=0):
    assert max(ds.keys())<=n_wounds
    res = defaultdict(lambda: 0)
    for k1,v1 in da.items():
        for k2,v2 in ds.items():
            kv = k1+k2
            mod,k1f = n_wounds, k1
            if first_n: # Handle first threshold separate
                if k1<first_n:
                    mod = 0 # i.e. ignore mod part in overflow code below
                    kv = min(k1+k2,first_n) # just set the kv
                else: # Past first threshold, so business as usual
                    k1f = k1-first_n # Reduce k1 by first_n for mod purposes
            
            # Remove overflow from overkilling unit
            if mod and k1f%mod + k2 > mod: 
                kv -= (k1f+k2)%mod
            
            #print("  ",k1,k2,mod,kv)

            res[kv] += v1*v2
    return res



# Create res as weighted sum of repeated convolutions with weights given by b_dd and repeated self-convolutons of r_dd
def dam_dd_over_dd(b_dd,r_dd,base=0,**argv):
    cur_d,res_d = {base: 1.0}, {0: b_dd.get(0,0.0)}
    for i in range(1,dd_max(b_dd)+1):
        cur_d = dam_convolve(cur_d,r_dd,**argv)
        if i in b_dd:
            res_d = add_ddist(res_d,mult_ddist_probs(cur_d,b_dd[i]))
    return dict(res_d)

# %% ../nbs/01_dists.ipynb 14
# Final end-to-end calculation for a weapon
# Range can be True (is in half distance), False (is not) or number of inches
def dam_dist(wep,target,situation={},n=1,fulldist=False,spillover=False):

    # Situation modifiers
    situation = {**{'range':False, 'cover':False, 'overwatch':False, 'indirect':False},**situation}
    if situation['range'] not in [True,False]: situation['range'] = (situation['range']<=wep['range']/2)

    # Successful attack dist
    sa_d = successful_atk_dist(wep,target,situation)

    # Repeat succ. attack dist n times
    sar_d = dd_rep(sa_d,n)

    # Single damage dist
    sd_d = single_dam_dist(wep,target,situation)

    # Find unit wounds
    unit_wounds = target['wounds']*target.get('models',1)
    
    if not fulldist: # Return regular dist    
        res_d = dam_dd_over_dd(sar_d,sd_d,n_wounds=target['wounds'])
        if not spillover: res_d = dd_cap(res_d,unit_wounds) 
    else: # Return a list of dists, one with first_n for each of 0 ... target['wounds']-1 values
        res_d = [ dam_dd_over_dd(sar_d,sd_d,n_wounds=target['wounds'],first_n=n_f) for n_f in range(target['wounds'],0,-1) ]
        if not spillover: res_d = [ dd_cap(d,unit_wounds-i) for i,d in enumerate(res_d) ]
            
    return res_d

# %% ../nbs/01_dists.ipynb 16
# Convolution of 'full' distributions i.e. when we have one for each mod n_wounds value
def fulldist_convolve(fd1,fd2,n_wounds):
    fres = []
    for f_n,d1 in enumerate(fd1):
        res = defaultdict(lambda: 0)
        for k1, v1 in d1.items():
            d2 = fd2[(k1+f_n)%n_wounds]
            for k2,v2 in d2.items():
                kv = k1+k2
                res[kv] += v1*v2
        fres.append(res)

    return fres

